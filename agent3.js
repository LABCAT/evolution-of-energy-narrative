//their are five phases used to describe the current state of nature
//the earth phase is a shorter phase that occurs in between each of the other phase
var phases_of_nature  = [
				['earth', 18],
				['wood', 72],
				['earth', 18],
				['fire', 72], 
				['earth', 18], 
				['metal', 72], 
				['earth', 18], 
				['water', 72]
			];

//keeps track of which phase is the current state			
var phase_pointer = 0;

//current phase
var current_phase = 'earth';

//days remaining in this phase 
var days_remaining = 18;

//the five agent types are represented as follows
var elements = [
				'earth',
				'metal',
				'fire',
				'wood',
				'water'
				];

//if an agent collides with a particular neighbour its size will be increased
var generated_by = {
					'metal' : 'earth', //metal is generated by earth
					'water' : 'metal', //water is generated by metal  
					'wood'  : 'water', //wood is generated by water  
					'fire'  : 'wood',  //fire is generated by wood 
					'earth' : 'fire'   //earth is generated by fire
				};
				
//if an agent collides with a particular neighbour it will be overcome by it and change to its state				
var overcome_by = {
					'earth' : 'wood', //earth is overcome by water
					'metal' : 'fire',  //metal is overcome by fire
					'water' : 'earth', //water is overcome by earth
					'wood'  : 'metal', //wood is overcome by metal
					'fire'  : 'water'  //fire is overcome by water
				};

function Agent3Preload() {  

}				

function Agent3() {
  //the size multiplier determines how big an agent will be - it ranges from 1.00 2.00
  this.max_size = 0;
  this.size_multiplier = 0;
  //variable used to prevent the size from changing to easily
  this.steps_between_size_change = 1;

  // setup is run when the agent is reset
  // value is a number between 0 and 100
  this.setup = function(value, agent_type, agent_size) {
  	//during setup the only agent type greater than 0 are setup
   	if(agent_type > 0){
	   	//set the agent_type using the elements array
	    this.agent_type = elements[agent_type];
	    this.max_size = agent_size;
	    this._size = this.max_size/4;
	    this.size_multiplier = this.max_size/4;
	    this.number_steps = 10;
	    this.current_direction = p5.Vector.random2D();
    }
    //0 is not set up because instead we create an extra agent type 'sun' 
    //this agent type is the only truly static agent type
    //it is not not affected by other agents, it does not move and it does not change size
    else {
    	this.agent_type = 'sun';
    	this._size = agent_size * 2;
    }
  }

  // this happens generally on mouse over
  this.activate = function() {
    this.power = 100.0;
  }

  // decide on your next move based on neighbors (but don't do it yet)
  this.step = function(neighbors, radius) {
  	if(this.agent_type == 'sun'){
  		return;
  	}

  	var become_current_phase = random(0, 100);
  	//there is a 0.1% chance that an agent will be reborn as the element of the current phase
  	//this ensure that none of the 5 different agent types will evey become extinct
  	if(become_current_phase < 0.1){
  		this.agent_type = current_phase;
  	}

  	//an agent can only move when it is not equal to the current phase in nature
    if(this.agent_type != current_phase) {
		this.number_steps = this.number_steps - 1;
		if(this.number_steps < 0) {
			this.number_steps = 30;
			this.current_direction = p5.Vector.random2D();
		}
		v = this.current_direction.copy().mult(radius/10);
    }

	for(var i=0; i<neighbors.length; i++) {
		var npos = neighbors[i].pos;
		var d = npos.mag();
		//if there is a collision then the agent may change state or increase size depending on which agent it has collided with
		if ((d > 0) && (d < radius + neighbors[i].radius)) {
			// Calculate vector pointing away from neighbor
			var move_away = npos.mult(-3);
			move_away.normalize();
			move_away.mult(d*.1); // Weight by distance
			v.add(move_away);
			//an agent will only increase in size if it is equal to current_phase and collides with an agent that it is generated by
			if(this.agent_type == current_phase && neighbors[i].agent.agent_type  == generated_by[this.agent_type]){
				this.steps_between_size_change -= 1; 
				//make sure the value for size is never higher than the max size
				if(this._size < this.max_size && this.steps_between_size_change == 0) {
					this._size += this.size_multiplier;
					this.steps_between_size_change = 10;
				}
			}
			
			//an agent will only change to a different agent if is not equal to current_phase and collides with an agent that it is overcome by
			if(neighbors[i].agent.agent_type  == overcome_by[this.agent_type]){
				if(this.agent_type != current_phase){
					this.agent_type = overcome_by[this.agent_type];
				}
				else {
					if(this._size > this.size_multiplier && this.steps_between_size_change == 0) {
						this.steps_between_size_change -= 1;
						this._size -= this.size_multiplier;
						this.steps_between_size_change = 10;
					}
				}
			}
		}
	}
	
	//return v if the agent_type is not the current phase
    if(this.agent_type != current_phase) {
		return v;
    }
  }

  this.draw = function(radius) {
    strokeWeight(0);
    var size = radius * 4;
    if(this.agent_type == 'earth') {
      	fill(255);
    }
    else if(this.agent_type == 'metal') {
      	fill(0, 0, 0);
    }
    else if(this.agent_type == 'fire') {
      	fill(255, 0, 0);
    }
    else if(this.agent_type == 'wood') {
      	fill(0, 255, 0);
    }
    else if(this.agent_type == 'water') {
      	fill(0, 0, 255);
    }

    if(this.agent_type == 'sun'){
    	fill(255, 255, 0);	
    	size = size/4;
    	hexagon(0, 0, size);
    }
    else {
    	ellipse(0, 0, size, size);
    }    
  }
}

/*
 * function to draw a hexagon shape
 * adapted from: https://p5js.org/examples/form-regular-polygon.html
 * @param {Number} x       	- x-coordinate of the hexagon
 * @param {Number} y    	- y-coordinate of the hexagon
 * @param {Number} radius   - radius of the hexagon
 */
function hexagon(x, y, radius) {
  angleMode(RADIANS);
  var angle = TWO_PI / 6;
  beginShape();
  for (var a = TWO_PI/12; a < TWO_PI + TWO_PI/12; a += angle) {
    var sx = x + cos(a) * radius;
    var sy = y + sin(a) * radius;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}
